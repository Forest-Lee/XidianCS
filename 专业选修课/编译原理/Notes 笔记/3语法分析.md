*2019 04 16*

# 第三章 语法分析

> 1. 语法规则：**上下文无关文法**
> 2. 语法分析：下推自动机，**自上而下和自下而上分析**

![mark](http://media.sumblog.cn/blog/20190416/6HHDyvPIyEqG.png?imageslim)

## 语法错误的处理方法

1. 源程序中可能出现的错位
   - 词法错误：非法字符、写错关键字
   - 语法错误：语法结构出错，缺少分号、不配对
   - 静态语义错误：类型不一致，参数不匹配
   - 动态语义错误：无穷递归，除 0



## 上下文无关文法 CFG

### CGF 的定义和表示

CFG 是一个四元组 G = (N, T, P, S)

- N 是非终结符的有限集合 （可以出现在产生式左边符号的集合）

- T 是终结符的有限集合 （可以出现在产生式左边符号的集合） 

- P 是产生式(Productions) 的有限集合

  $A\to a$ 

- S 是非终结符，称为文法的开始符号，一般出现在第一个产生式的左部

**上下文无关是指完成产生式的替换之后，不影响表达式的正确性**

> 例子：
>
> 简单算术表达式的上下文无关文法的表示
>
> ![mark](http://media.sumblog.cn/blog/20190416/jjlBlopH9BLF.png?imageslim)

**终结符与非终结**

**符书写上的区分**

  (a) 用**大小写**区分：   E → id

  (b) 用**"  "**区分：        E → "id"     E → E "+" E

  (c) 用**< >**区分：         <E> → <E> + <E>  

  教材约定：大写英文字母A、B、C表示非终结符；

​                        小写英文字母a、b、c表示终结符；

​                      小写希腊字母α、β、δ表示任意文法符号序列

**产生式的缩写**

当多个产生式的左部非终结符相同时，可合并为一个产生式。新的产生式的左部是此非终结符，右部是所有原来右部的**或运算**（并集合）使用符号 `|`

**产生式通过推导的方法来产生语言**

> 推导的形式化定义：
>
> - 直接推导：用产生式的右部替代文法符号序列中的元素
>
> 推导具有自反和传递性

**上下文无关语言**

由终结符构成的串，叫做 **句子**

由终结符和非终结符构成的串，叫做 **句型**

> 在推导过程中，如果每次直接推导均替换句型中最左边的非终结符，则成为最左推导。由最左推导产生的句型称为：左句型

一个给定的文法可以唯一确定他所产生的语言，但是对于一个给定的语言来说，可以用若干不同的文法来产生。

![mark](http://media.sumblog.cn/blog/20190416/Wzccz5QBYnwi.png?imageslim)





# 二义性与二义性的消除

1. 改写二义文法为非二义文法

   算符优先文法：越靠近文法的开始符号，优先级越低

   - 新引入的非终结符，限制了 每一步直接推导均有唯一选择
   - 非终结符的引入，增加了推导步骤

   **如何改写【**

   引入新终结符，增加一个子结构，提高一级优先级

   递归非终结符在终结符左边，运算具有左结合性，否则具有有结核性



### 消除文法的左递归

建立语法数的时候会在左分支陷入死循环

## 提取左因子

消除回溯，凡是前面相同的，将其提取，其右部合成为新的非终结符

**当既含有左递归，又含有左因子时，先消除左递归**

## 递归下降分析

状态图的化简：

标记为 A 的边等价于标记 e 的边转向 A 转换图的初态

标记相同的路径可以合并

不可区分的状态可以合并







# 预测分析器

**非递归预测分析器的工作模式**

1. 分析方法：格局与格局变换
2. 分析表+驱动器
3. 预测分析表的构造
4. LL文法 (无左递归，无公共左因子)

### 预测分析表

最左一列：所有的非终结符

最上一行：所有的终结符

M[A,a] 若当前栈顶是非终结符 A，下一输入终结符是 a 则 M[A,a] 指示下一步的动作

如何扩展？将 M 入栈 （反序进栈）

1. 匹配终结符
2. 展开非终结符
3. 报告分析成功

**工作方式**

从初始格局开始，经过一系列的格局变化，最终到达接受格局，表明分析成功

到达出错格局，表明发现一个错误

**格局：**

格局是一个三元组：栈内容，当前剩余输入，改变格局的动作

**改变格局的动作**

1. 匹配终结符：当前是终结符，且栈顶是终结符，那么栈顶出栈
2. 展开非终结符：当前是终结符，栈顶是非终结符，非终结符出栈，查表反向入栈
3. 报告分析成功：栈顶和当前都是结束符 #
4. 报告出错：所有其他情况

## 构造预测分析表

- **first 集合**

  First($\alpha$) 是一个串经过一步或多不推导之后，在句型头部最左边出现的终结符

- **follow 集合**

  FOLLOW（A） 是所有句型中，能紧跟在非终结符 A后面的终结符 a

**First 集合计算算法**

1. 如果 x 是终结符 firstx = x
2. x是非终结符，且 x-> y1y2y3, 那么 x 的first 集与 y1 的first 集相同，特别的，如果 y1 可以推出空串，那么 x 的first 集还包含y2 的first 集， 以此类推

**Follow 集合计算算法**

1.  `#` 是 S 的FOLLOW 集合
2. 如果有 A-> aBb, first b 的全体加入 folllow B
3. 如果A->aB 那么 FOLLOW A 的全体加入 FOLLOW B

*自下而上计算 FIRST， 自上而下计算 FOLLOW*

**怎么填表**

![mark](http://media.sumblog.cn/blog/20190514/yWNL4J6izJDg.png?imageslim)

## LL(1) 文法

L: 自左向右读入

L: 最左推导

1：只向前看1个字符

当且仅当构造的预测表中不含多重定义的条目，这种语言叫做 LL（1）语言

如何判断：

1. **构造分析表** 没有多入口的分析表
2. 



## 自下而上的语法分析

- 自上而下：从文法的开始符号出发，反复使用各种产生式，寻找匹配的推导
- 递归下降分析：对每一个语法变量构造一个响应的自身徐，每个子程序识别一定的语法单位，通过子程序间的信息反馈和联合作用实现对输入串的识别

**自下而上分析法：**

从输入串开始，逐步 **规约** 直到文法的开始符号，从树的末端开始，构造语法树

> **规约：** 规矩文法的产生式规则，把产生式的右部替换成左部符号

**LR分析法**：从左到右读入输入串，最右推导的逆过程

**思路：** 从左到右扫描。反复用产生式的左部替换产生式的右部，谋求对输入串的匹配，最终得到文法的开始符号。

### 规范规约与 「剪句柄」

![mark](http://media.sumblog.cn/blog/20190514/lb3RChFDWTOP.png?imageslim)

短语是句型中的某部分

![mark](http://media.sumblog.cn/blog/20190514/U9cjjA3hNdN0.png?imageslim)

把输入符号进栈，如果栈顶元素可规约，那么就规约

句柄总是在栈顶形成（最左规约）

栈中保留的总是一个右句型的前缀（活前缀）

最左规约是逻辑上从下到上构造一颗语法数，从下到上为语法数剪句柄

**需要解决的问题**

1. 如何保证栈中总是活前缀
2. 如何确定栈顶已经形成句柄并选择正确的产生式进行规约

找句柄：找树中最左，最深的子树

规范规约是一个 **最右推导的逆过程**

最左规约 是  规范推导

由规范推导推出的句型，称为规范句型

**移进规约：**

用一个栈，记住规约句柄的前缀，句柄未形成，向前移进

![mark](http://media.sumblog.cn/blog/20190514/XAd79qHDvW5t.png?imageslim)

### LR 分析器

把「历史」和「展望」综合抽象成状态，由栈顶的状态和现行的输入符号唯一确定每一步动作

LR 分析器的核心是分析表

### LR 分析表的构造

> 句柄都是在活前缀中出现的，在句柄之上不可能出现其他符号
>
> **构造一个可以识别文法中所有活前缀 的 DFA**

- 活前缀：出现在移进-规约分析器栈中的右句型的前缀
  - 右句型的前缀
  - 已经在分析栈中

#### LR(0) 项目集族的构造

- 字的前缀：字的任意首部
- 活前缀：不含句柄之后的符号
- 项目：在所有产生式的所有位置分别加一个点 .

每个项目显示了分析过程中看到（移进）了产生式的多少，$A\to\alpha.\beta$ 

- $\beta$ 不为空的项目称为**可移进项目**
- $\beta$ 为空的项目称为 **可规约项目**
- . 点 到达最右方的时候，表示产生了句柄

**构造活前缀的 NFA**

若状态i ： 



## LR(0) 分析表的构造

![mark](http://media.sumblog.cn/blog/20190523/iDQLkTwUBPR0.png?imageslim)

在同一状态中，若既有可规约项目，又有可移进项目时，存在移进和规约的冲突

如果存在两个可规约项目，即存在规约和规约的冲突 

**解决办法：**简单向前看一个终结符

如果冲突可以解决，文法为 SLR(1) 文法 ：简单的 LR 分析法

![mark](http://media.sumblog.cn/blog/20190523/dXlIQbSRF5QL.png?imageslim)

如果 SLR(1) 无法解决冲突，

那么每个项目需要带上 k 个终结符，这样一个项目称为 LR(k) 项目

