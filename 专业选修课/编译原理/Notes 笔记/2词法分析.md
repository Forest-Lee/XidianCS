# 词法分析

> 从左到右逐个字符读入源程序，，对构成源程序的字符流进行扫描和分解，识别出一个个单词，把作为字符串的源程序改造为单词符号串的中间程序

## 2.1 词法分析中的若干问题

### 记号、模式与单词

**单词的基本分类**

- 关键字
- 标识符
- 字面量
  - 数字量、字符量、逻辑量、宏定义
- 运算符
- 分隔符

**模式：**产生和识别元素 （构词）规则

**记号（token）：** 按照模式，识别出的元素

**单词 （lexeme）：** 被识别出的元素自身的值，称为词值

1. 过滤掉源程序的无用成分（注释、空格、回车）
2. 处理与具体平台有关的输入 （文件结束符的不同表示）
3. 识别记号，交给语法分析器，根据模式识别记号
4. 调用符号表管理器或出错处理器





## 模式的形式化描述

### 语言

==语言是有限字母表上有限长度字符串的集合==

> 与一般意义上的集合不同，有序

### 正规式与正规集 （正则表达式）

> 乔姆斯基体系

>令Σ是一个有限字母表，则Σ上的正规式及其表示的集合递归定义如下:
>       1. ε是正规式，它表示集合L(ε)={ε}
>       2. 若a是Σ上的字符，则a是正规式，它表示集合L(a)={a}
>       3. 若正规式r和s分别表示集合L(r)和L(s)，则
>       （a） r|s是正规式，表示集合L(r)∪L(s)， （r 或 s 出现）
>       （b） rs是正规式，表示集合L(r)L(s)， （r 和 s 连接）
>       （c） r*是正规式，表示集合(L(r))\*，(闭包 r 出现任意次)
>       （d）(r)是正规式，表示的集合仍然是L(r)
>       可用正规式描述的语言称为正规语言或正规集。   
>
>**正规式与正规集是一对多的关系**

**正规式**                 **正规集**  

a，b，c  {a}，{b}，{c} 

a|b，b|a  {a}∪{b}={a，b} 

a(a|b)*  {a，aa，ab，aba，abb，aab，...}，a为首的ab串 

∑*  {ε，a，b，c，aa，ab，ac，ba，bb，bc，...}

## 记号的定义

> 记号 = 正规式
>
> - 记号是正规式

```
relation = < | <= | <> | > | >= | =
id = (a|b|c|d|e|f|g|h|i|j|k|l|m|n|o|p|q|r|s|t|u|v|w|x|y|z
       |A|B|C|D|E|F|G|H|I|J|K|L|M|N|O|P|Q|R|S|T|U|V|W|X|Y|Z)
	   (a|b|c|d|e|f|g|h|i|j|k|l|m|n|o|p|q|r|s|t|u|v|w|x|y|z
	  |A|B|C|D|E|F|G|H|I|J|K|L|M|N|O|P|Q|R|S|T|U|V|W|X|Y|Z
	  |0|1|2|3|4|5|6|7|8|9)*
num = (0|1|2|3|4|5|6|7|8|9)(0|1|2|3|4|5|6|7|8|9)*
      	(ε|.(0|1|2|3|4|5|6|7|8|9)(0|1|2|3|4|5|6|7|8|9)*)
		(ε|E(+|-|ε)(0|1|2|3|4|5|6|7|8|9)(0|1|2|3|4|5|6|7|8|9)*)
```

- 简化的正规式
  1. 正闭包 `r+`
  2. 可缺省 `r? = r|e`
  3. 字符组 `[abc] [0-9a-z]`
  4. 非字符组 `[^abc]`
- 辅助定义式

## 3有限自动机

> - 模式的描述——正规式
> - 记号的识别——有限自动机

根据下一个状态是否确定，自动机分为确定有限自动机，非确定有限自动机

- 确定型速度快，但占用资源更多

### 状态转化图

![mark](http://media.sumblog.cn/blog/20190319/pbOy8UnR7tsP.png?imageslim)

识别标识符的状态转化图

### 不确定的有限自动机

> Nondeterministic Finite Automaton ，NFA）

NFA是一个五元组（5-tuple）：

  M =（S，∑，move，s0，F），其中

1. S是有限个状态（state）的集合；

2. ∑是有限个输入字符（包括ε）的集合；

3. move是一个**状态转移函数**，move(si，ch)=sj 表示，当  前状态si下若遇到输入字符ch，则转移到状态sj；

   > 不确定性的表现：转移到的状态可以不唯一

4. s0是唯一的初态（也称开始状态）；

5. F是终态集（也称接受状态集），它是S的子集，包含了所有的终态。

**直观的表示方式：**

1. 状态转换图

   ![mark](http://media.sumblog.cn/blog/20190319/Ef8jPXW0bMAO.png?imageslim)

   如何 识别记号：对于字符串，从初态开始，经过一系列的状态到达终态

2. 状态转换矩阵

   ![mark](http://media.sumblog.cn/blog/20190319/S1orT7hQ2v9l.png?imageslim)

   第i 个状态，遇到字符 a 变成第 j 个状态

> 例如：
>
> (a|b)*abb：
>
> ![mark](http://media.sumblog.cn/blog/20190319/TpRWJt3tYciP.png?imageslim)
>
> 不是处处有定义的：偏函数
>
> ![mark](http://media.sumblog.cn/blog/20190319/FU5wORaUTcQX.png?imageslim)

第一个填空题，第二个选择题，第三个判断题

NFA 当前状态下对同一字符有多于一个的下一状态转移

**不确定性的表现：**

1. 定义：move 函数是 1 对 多 的
2. 转换图：同一状态有多于一条边标记相同字符转移到不同的状态

### 确定的有限自动机

- 没有状态具有 ε 状态转移（ε-transition），即状态转  换图中没有标记 ε 的边；

- 对每个状态 s 和每个字符 a ，最多有一个下一状态。（可以没有转移）

## 从正规式到词法分析器

1.**描述**：用正规式对模式进行描述；

2.**构造****NFA**：为每个正规式构造一个NFA；

3.**确定化**：将NFA转换成等价的DFA；

4.**最小化**：优化DFA，使其状态数最少；

5.**构造词法分析器**：由DFA构造词法分析器。

给定一个正规式，构造出最小化的完整过程 **必考**

> Lec 工具实现了构造算法
>
> 有规范的一对一算法能构造出 NFA

**自动机等价的概念：**

如果 ：L(M1) = L(M2) 自动机识别的语言相同

它们识别同一个正规集，则称这两个自动机相等

**定理：** 一定存在一个确定型有限自动机和非确定型优先自动机等价

### 由正规式构造 NFA

**Tompson 算法** 必考

首先分解正规式

1. 对于  **ε** 直接构造 从 S0 到 f

2. 对于 $\Sigma$ 上的每一个字符 ，构造 $N(a)$ 接受 a

   ![mark](http://media.sumblog.cn/blog/20190402/m6yRORrXn9lr.png?imageslim)

3. 若 N(p) N(q) 是正规式 p q 的 NFA

   - 对于 p|q

     ![mark](http://media.sumblog.cn/blog/20190402/vI2m2Ea7HzHQ.png?imageslim)

     引入新的初态 s0 和终态 f，原来的专业关系不变，新增四个空转移 

   - 对于 pq

     ![mark](http://media.sumblog.cn/blog/20190402/BXqzXmSQgE2w.png?imageslim)

   - 对于 p*

     ![mark](http://media.sumblog.cn/blog/20190402/k2dDP8usuSrX.png?imageslim)

     闭包运算，出现 0 次或多次

   **构造新的 NFA 最多增加两个状态**

### 从 NFA 到 DFA 的转换

> 这一过程也叫 **确定化** 从 NFA 构造识别同样语言的 DFA 的算法称为子集构造法

让新构造的 DFA 的每一个状态，代表  NFA 的状态集

1. 消除空转移，——求闭包
2. 扩展状态转移函数，**消除多于一个的下一状态转移**





## DFA 的化简

- 等价状态的概念

  如果从两个不同的状态出发，经过一系列同样输入序列转化为同样的终态，则这两个状态是等价的



**算法**

1. 初始划分：划分为终态和非终态
2. 利用可区分的概念，反复划分 （看是否落回集合自身）
3. 由最终划分构造 D·
4. 消除可能的死状态和不可达状态



