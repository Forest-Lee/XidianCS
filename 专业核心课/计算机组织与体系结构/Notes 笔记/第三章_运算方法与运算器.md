# 第三章 运算方法与运算器

By: 诚夏 SincereXIA @ XD Univ.

<a rel="license" href="http://creativecommons.org/licenses/by-nc/3.0/cn/"><img alt="知识共享许可协议" style="border-width:0" src="https://i.creativecommons.org/l/by-nc/3.0/cn/88x31.png" /></a><br />本作品采用<a rel="license" href="http://creativecommons.org/licenses/by-nc/3.0/cn/">知识共享署名-非商业性使用 3.0 中国大陆许可协议</a>(Creative Commons Attribution 3.0 China Mainland License)进行许可。

------



> 运算器用于**数值计算**和**加工处理数据**
## 定点数加减运算

定点数加减可以用原、反、补、移码运算，只学习补码加减法。 

### 补码加减运算

**加法运算**
$$
[X+Y]_{补} = [X]_{补}+[Y]_{补}
$$
**减法运算**
$$
[X-Y]_{补} = [X]_{补}+[[Y]_{补}]_{求补}
$$
**规则：**
1. 两个加数用补码标识
2. 符号位也得加
3. 运算结果也是补码

**溢出判断**
> 只有同符号数相加、异符号数相减时，运算结果才有可能溢出
1. 双符号位判决法
    00 表示正号， 11 表示负号，若发生溢出，则符号位一定不一致
2. 进位判决法
    若负号位和数值位最高位均（未）发生了进位，则未溢出
3. 符进判决法
    运算结果的负数符号位发生了进位，则未溢出，正数符号位没有进位，则未溢出
4. 前后符号位判决法
    同号求和产生异号，异号求差与被减数异号则发生了溢出
### 一位全加器

![mark](http://media.sumblog.cn/blog/180506/2m65DKhCaJ.png?imageMogr2/thumbnail/!60p)
### n位加法器
1. 行波进位加法器
  ![mark](http://media.sumblog.cn/blog/180506/c4g0gd7fd0.png?imageMogr2/thumbnail/!60p)
  时延大
2. 先行进位加法器
  **先根据输入的数字，计算出每一位接受的进位，然后进位信号并行地接到加法器上，提高加法器的速度**
  ![mark](http://media.sumblog.cn/blog/180506/fjBKFBgkA2.png?imageMogr2/thumbnail/!60p)
  延迟时间图：
  ![mark](http://media.sumblog.cn/blog/180401/IiDBlbF01C.png?imageMogr2/thumbnail/!60p )
  第一位直接接受进位，因此没有T的延迟时间
### BCD 码加法器

1. 先用压缩的BCD码表示需要运算的数字
2. 压缩的 BCD 码直接相加
3. **矫正**
    1. 低四位相加的结果大于 9，则低四位加上 0110
    2. 高四位相加的结果大于 9，则高四位加上 0110
    
### 移码加法器

1. 先将移码直接求和差
2. 结果修正——**结果的符号取反**

## 定点数乘法运算
### 原码一位乘法

> **原则**
> 1. 乘积的符号为乘数和被乘数符号位的异或
> 2. 乘积的绝对值为被乘数的绝对值和乘数的绝对值之积

使用 D 寄存器储存临时和，使用 A 寄存器储存乘数
**步骤**
1. 首先确定乘积的符号位

2. 将DA进行拼接，每次根据 A0 ，使 D+0 或 D+被乘数

3. DA 整体右移一位，得到新的 A0

4. 当 A 中不再有被乘数时，结束计算

5. 符号位与临时积拼接，得到最后的结果

  ![mark](http://media.sumblog.cn/blog/180506/C2lC2HJJLd.png?imageMogr2/thumbnail/!60p)

  > ［X］原＝0.1101，［Y］原＝1.1011，求两者之积。
  >
  > >  解 ：利用被乘数与乘数的符号，求出乘积的符号为0 ⊕1 ＝1 ![mark](http://media.sumblog.cn/blog/180506/CJLGfeKa9h.png?imageMogr2/thumbnail/!60p)

### 原码二位乘法

![mark](http://media.sumblog.cn/blog/180401/f27A99gJIJ.png?imageMogr2/thumbnail/!80p)

二位乘法在每次右移时，移动两位，乘数的最后两位共有四种可能性，但是加3不易操作，因此，加三操作先在本位减去乘数，移位后再加一遍乘数

>  设X＝＋0.100111，Y＝－0.100111，利用原码求积。
>
> ​     ![mark](http://media.sumblog.cn/blog/180506/8hCgj9IDgC.png?imageMogr2/thumbnail/!70p)

### 补码一位乘法

#### 校正法

1. 从补码表示的乘数最低位开始，若为1则加补码表示的被乘数［X］补。若为0则加0。
2. 部分积右移一位，再看乘数的下一位，若为1则加补码表示的被乘数［X］补。若为0则加0。
3. 重复②直到乘数各位（除符号位）全都做完，获得结果。
4. 最后，根据乘数的符号位Y0的状态进行校正。若Y0＝1，则在③的结果上加［－X］补；若Y0＝0，则③的结果就是要计算的乘积。 

#### 布斯（Booth）法

1. 先将两数用补码表示

2. A 寄存器中存入 **补码表示的** **带符号的** 乘数， 多加一位 $A_{-1}$ , 初始值设为 0， 最前方的符号位使用 两位表示

3. 通过观察 A 的末位 和 A-1 位的状态，判断当前的操作

   | A0   | A-1  | 操作                |
   | ---- | ---- | ------------------- |
   | 0    | 0    | 右移一位            |
   | 0    | 1    | + [x]补 ， 右移一位 |
   | 1    | 0    | +[-x]补 ， 右移一位 |
   | 1    | 1    | 右移一位            |

   ![mark](http://media.sumblog.cn/blog/180506/0E7H6gjFEH.png?imageMogr2/thumbnail/!60p)

   > 已知X＝0.1010, Y＝－0.1101。利用布斯法补码一位乘法求积。 
   >
   > 首先将两数用补码表示：     ［X］补＝00.1010，［Y］补＝11.0011，而［－X］补＝11.0110。 
   >
   > ![mark](http://media.sumblog.cn/blog/180506/5HkAgjChCD.png?imageMogr2/thumbnail/!60p)

### 补码二位乘法

**原理**： 

$$2(Y_{i-1}+(Y_{i-2} - Y_{i-1} )= Y_{i-1} + Y_{i-2} - 2Y_{i}$$

1. 乘数与被乘数均用补码表示，连同符号位一起参加运算。
2. 乘数最低位后增加一个附加位（可用A－1），初始设定为0。
3. 从附加位开始，依据操作规律，一次检测相邻3位决定具体的操作，并每次乘数右移2位。 
4. 当乘数（包括符号位）位数为偶数n时，右移次数为n/2次，最后一次只右移1位。

![mark](http://media.sumblog.cn/blog/180405/2Ic1jB3G64.png?imageMogr2/thumbnail/!60p)

> 已知X＝－0.1101，Y＝－0.1011，试利用补码二位乘法求积。 
>
> 写出［X］补＝1.0011，［Y］补＝1.0101
>
> ​    为了在求解过程中不至于溢出，被乘数X拟用3个符号位，求解过程中所用到的数值表示为：
>
> ​    ［X］补＝111.0011        2［X］补＝110.0110 
>
> ​    ［－X］补＝000.1101      2［－X］补＝001.1010
>
> ​    同时，在这里利用将乘数的符号位增加一位，使其变为［Y］补＝11.0101。  
>
> ![mark](http://media.sumblog.cn/blog/180506/ilH6hCEBbd.png?imageMogr2/thumbnail/!60p)

## 定点数除法运算

### 原码除法运算

**法则** ：

1. 除数不为0
2. 定点纯小数： |被除数| < |除数|
3. 商的符号是被除数和除数的符号异或

**恢复余数法**

1. 被除数（余数）放在 （DA）寄存器
2. 每次左移一位，并减去除数的绝对值
3. 够减， 则上商为1
4. 不够减， 则上商为 0 ， 并加回减数

**加减交替法**

1. 若够减，上商1 ，左移一次，减除数

2. 若余数<0, 上商 0， 左移一次， 加除数

   ![mark](http://media.sumblog.cn/blog/180506/m9gjiC3a8b.png?imageMogr2/thumbnail/!70p)

> 若X＝-0.10001011，Y＝0.1110  试利用原码加减交替法求商及余数。 
>
> [X]原＝1.10001011，[Y]原＝0.1110， 商符＝1⊕0＝1
>
> ![mark](http://media.sumblog.cn/blog/180506/dbi871e2e7.png?imageMogr2/thumbnail/!70p)
>
> 最终，商为 1.1001 余数为：0.1101*2^-4

### 补码除法运算

1. 运算规则

   1. **一上来，不移位，直接做一次加减法：**

      被除数[X]补与除数[Y]补同号，商为正，做减运算；

      被除数[X]补与除数[Y]补异号，商为负，做加运算。

   2. 进行循环操作：

      若余数[Ri]补与除数[Y]补同号，上商‘1’，左移一位，减除数；

      若余数[Ri]补与除数[Y]补异号，上商‘0’，左移一位，加除数。

   3. **只要除不尽，末位恒置一**

   4. **商的符号位和数值位均在运算中产生**

![mark](http://media.sumblog.cn/blog/180506/AhfFC1A9Al.png?imageMogr2/thumbnail/!60p)

> 若X＝-0.10001011，Y＝0.1110，用补码除法求X÷Y。
>
> 解：[X]补＝1.01110101，[Y]补＝0.1110，[-Y]补＝1.0010 
>
> ![mark](http://media.sumblog.cn/blog/180506/1F3lK5E3l4.png?imageMogr2/thumbnail/!70p)

## 浮点数运算

### 浮点数加减运算

1. **阶码来対阶**

   小阶对大阶，将小阶码变成大阶码。小阶码每增加1，其相应的尾数右移一位，直到增大到与大阶码相同

2. **尾数相加减**

   使用补码的运算规则进行计算，**计算时，使用双符号位**

3. **最后规格化**

   在浮点数加减运算时，右规最多1次。若发生上溢出，可认为结果为∞ 

> 两浮点数为：
>
> ​     $X=0.110101×2^{-010}$              $  Y=－0.101010×2^{-001}$
>
> 求两数之和及差。
>
> 解：设两浮点数阶码为4位，用补码表示。尾数用8位，均用双符号位补码表示。则两数可表示为：
>
> ​    ﹝X﹞补=1110；00.110101
>
> ​    ﹝Y﹞补=1111；11.010110 
>
> 1. 对阶
>
>    求阶差：﹝△E﹞补=﹝EX﹞补 ＋﹝－EY﹞补 ﹦1110＋0001﹦1111。即X的阶码比Y的阶码小。         
>
> 因此，X尾数右移一次，使两者阶码相同。这时的X为：﹝X﹞′补=1111；00.011011，采用的是0舍1入法。
>
> 2. 尾数求和：                     尾数求差：
>
> ​                  00.011011                     00.011011
>
> ​             ＋ 11.010110                 ＋ 00.101010
>
> ​                  11.110001                     01.000101  
>
> 3. 规格化
>
>    从相加的结果可以看到结果为一非规格化尾数。需将尾数左移2位，变为11.000100。同时，阶码减2，则阶码变为1101。
>
>    最后，得到两数相加结果为；
>
>    ​         ﹝X+Y﹞浮=1101；11.000100。 

### 浮点乘除运算

1. **阶码相加减**

   求乘积的阶码，即Ez=Ex+Ey。并判断积的阶码是否溢出。 

2. **尾数做乘除**

3. **规格化**