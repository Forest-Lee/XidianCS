# 第五章 指令系统

## 1. 指令系统结构层

### 存储模式

1. 数据存储顺序

   - **大端存储：** 高位字节保存在内存的低地址
   - **小端存储：** 低位字节保存在内存的低地址

2. 堆栈

   > 堆栈是主存中被特殊定义的一块存储区域，遵循后进先出的操作规则

   堆栈采用隐含寻址的方式寻址，使用三个寄存器管理堆栈：

   - 堆栈指针、堆栈基址、堆栈界限

### 寄存器组织

典型的寄存器有：地址寄存器、数据寄存器、指令寄存器、程序寄存器、堆栈寄存器、标志寄存器

### 数据类型

数值型数据、非数值型数据

### 指令

#### 1. 指令的组成

> 指令由 **操作码字段** （表征指令的操作特性与功能）和 **地址码字段** （指定参与操作的操作数的地址） 组成

#### 2. 指令的格式

- 操作码设计

  - 定长操作码

  - 不定长操作码

    - 霍夫曼编码

    - 拓展操作码

      | 等长拓展方式                                                 | 非等长拓展方式                                               |
      | ------------------------------------------------------------ | ------------------------------------------------------------ |
      | ![mark](http://media.sumblog.cn/blog/180522/5b3KebiL4E.png?imageslim) | ![mark](http://media.sumblog.cn/blog/180522/FH9eaLEHG8.png?imageslim) |

    - 依据地址码数量扩展操作码

- 操作数地址字段的位数

  操作数地址字段的位数决定了**内存的规模**

- 地址码的数目

  - 零地址指令

    > 只有操作码，没有操作数地址的指令格式

    这种指令无需任何操作数，如空操作 `NOP` 停机指令`HLT`

    或者所需的操作数是默认的，如堆栈

  - 一地址指令

    > 单操作数指令，指令中给出的地址，既是操作数的地址，又是操作结果的存储地址

    或者另一个操作数由机内硬件寄存器隐含提供

  - 二地址指令

  - 三地址指令

#### 3. 指令的类型

1. **数据传送类**

   > 指令源和目的操作数的位置，指明要传送数据的长度，指明寻址方式

2. **算数运算类**

3. **逻辑运算类**

4. **数据转换类**

   > 完成对数据格式进行转换操作

5. **输入输出类**

   > 主机与外设之间的信息交换：输入输出数据、发送控制命令、了解工作状态

6. **系统控制类**

   > 通常是特权指令，由操作系统或系统软件调用，用于系统资源的分配和管理、在多任务计算机系统中必须设置，某些输入输出指令也被列为特权指令

7. **控制传递类**

   > 用于程序流程控制，调用、返回、中断；循环控制；转移

   - 转移指令
     - 无条件转移指令：JMP
     - 条件转移指令：可以对设定条件进行测试，满足时转移
   - 循环控制：如 x86 中的 LOOP 指令
   - 控制传递：调用和返回指令、中断指令：`INT n`

#### 4. 数据寻址方式

> 寻址方式：指令按什么方式找到所需的操作数或信息

- 寻址方式的区分方法：

  - 隐式区分：由操作码确定寻址方式
  - 显式区分：在指令中设置寻址方式字段

- 寻址位置：

  通用寄存器、主存、堆栈、外设端口寄存器

##### 寻址方式

1. **隐含寻址**

   操作码决定了操作数的存放地址，指令中完全不给出地址

2. **立即寻址**

   指令中直接给出了需要操作的数据，完全不需要寻址

3. **直接寻址** ：$EA=X$

   操作数在主存中，地址在指令中，根据地址访问一次主存可获得操作数

4. **间接寻址** ：$EA=(X)$

   操作数在主存中，操作数的地址在主存中，根据指令地址访问两次主存得到操作数

5. **寄存器寻址**：操作数在指令指定的寄存器中

6. **寄存器间接寻址**：操作数地址在寄存器中，操作数在主存中

7. **相对寻址**：$EA=(PC)+D$

   程序计数器中的地址为基准地址，指令给出偏移地址 D ，用作程序跳转

8. **基址寻址** ：$EA=(RB)+D$

   指令中给出基址寄存器寻址位 B，或者寄存器地址 RB，给出偏移地址 D（即形式地址，带符号整数补码），两者求和得出操作数的有效地址

   > 1. 基址寻址可以扩大我们的寻址范围，因为基址寄存器的位数可以大于形式地址A的位数。 
   > 2. 基址寻址在多道程序中极为有用。比如在汇编当中，我们有多个段，有时我们不必关心自己的程序位于哪一个位置，我们只需要给出基址寄存器，操作系统或者管理程序就可以根据主存空间状况，为我们指定的基址寄存器赋一个初值。 

9. **变址寻址**：$EA = (RI)+D$

   自动变址功能：寻址得到操作数后，变址寄存器内容会自动修改

   > 基址寻址中的基址寄存器的内容通常由操作系统或者管理程序决定，在程序执行过程中是不可变的，而指令字中的 D 是可变的。变址寻址中变址寄存器的值 RI 是由用户设定的，在程序执行过程中是可变的，而指令字中的 D 是不可变的。  







