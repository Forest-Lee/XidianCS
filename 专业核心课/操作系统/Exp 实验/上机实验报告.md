## 实验五 信号量实现进程同步

### 实验目的

> 进程同步是操作系统多进程/多线程并发执行的关键之一，进程同步是并发进程为了完 成共同任务采用某个条件来协调他们的活动，这是进程之间发生的一种直接制约关系。本 次试验是利用信号量进行进程同步。 

### 实验软硬件环境

**软件环境**：gcc version 7.3.0 (x86_64-posix-sjlj-rev0, Built by MinGW-W64 project)，Windows10 1607 OS Version 1493.2068

**硬件环境**：处理器：Intel（R）Core（TM）2 Duo CPU E7500@2.93GHz 2.94 GHz 已安装的内存（RAM）：4.00GB

### 实验内容

> 生产者进程生产产品，消费者进程消费产品。当生产者进程生产产品时，如果没有空缓冲区（仓库）可用，那么生产进程必须等待消费者进程释放出一个缓冲区，当消费者进程消费产品时，如果缓冲区产品，那么消费者进程将被阻塞，直到新的产品被生产出来。模拟一个生产者两个消费者的情况。 

程序模板：

```c
#include<unistd.h>
#include<sys/types.h>
#include<sys/stat.h>
#include<fcntl.h>
#include<stdlib.h>
#include<stdio.h>
#include<string.h>
#include<sys/sem.h>
union semun{  
    int val;  
    struct semid_ds *buf;  
    unsigned short *arry;  
};  
//基本量定义（三种信号量、P操作、V操作、初始化/删除信号量）
int main(intargc, char *argv[])
{
//创建信号量
//程序第一次被调用，初始化信号量
//set_semvalue三种信号量的判断
    pid_t p1,p2;
//pv操作
}
staticint set_semvalue(intsem_id,intvalue)
{
//用于初始化信号量，在使用信号量前必须这样做
}
staticvoid del_semvalue(intsem_id)
{
//删除信号量
}
staticint semaphore_p(intsem_id)
{
//对信号量做减1操作，即等待P（sv）
}
staticint semaphore_v(intsem_id)
{
//一个释放操作，它使信号量变为可用，即发送信号V（sv）
}

```

###  实验程序及分析

**实验程序：**



**实验分析：**

1. 本次实验通过封装 C 语言内置函数实现信号量以及 p、v 操作

2. 信号量的创建使用 semget() 函数进行实现，函数原型为：

   `int semget(key_t  key, int num_sems, int sem_flags);  `

   本次实验，我们需要创建 `full`、`empty`、`mutex` 三个信号量，分别表示产品个数，缓冲区空位个数，对缓冲区进行操作的互斥信号量 

3. 信号量的初始化操作由 `sectl` 函数进行，实验中对该函数进行了二次封装，实现对三个信号量初值的设定操作，在本实验中， `full`、`empty`、`mutex` 三个信号量的初值分别是 0、n、1

4. 信号量的 P、V 操作由 `semop` 函数实现，其原型为：

   `int semop(int sem_id, struct sembuf *sem_opa, size_tum_sem_ops);   `

   通过修改 `sembuf`结构体中 `sem_op` 的值，实现对应的 P、V 操作

5. 本次实验模拟生产者和消费者之间的同步关系，故需要执行两次 `fork` 操作，得到三个进程：一个生产者，两个消费者，使用封装好的 `semaphore_p(int sem_id)` 和 `semaphore_v(int sem_id)` 操作来进行同步关系的模拟

   

### 实验心得及体会

本次实验较前几次实验来说，感觉难度明显增大，难度提高的原因：一是代码长度大大增长，本次实验所用到的很多功能都需要再次封装，实验的代码逻辑也较上几次复杂；二是实验中引入的函数数量明显增加，并且这些函数的参数结构复杂，很多函数使用了结构体进行传参，并且需要进行权限的设置。通过本次实验，我了解了 Linux 系统中信号量实现进程同步的一种方式，掌握了信号量的初始化以及 P、V 操作的实现方法。并通过调用自己封装的信号量操作函数，实现了生产者消费者同步关系的模拟。通过本次实验，提高了我编写复杂代码解决问题的能力，使我对信号量的实现方式以及操作流程有了更为深入的了解。





## 实验六 共享主存实现进程通信

### 实验目的

> 利用共享主存解决读写者问题。要求写者进程创建一个共享主存，并向其中写入数 据，读者进程随后从该共享主存区中访问数据。 

### 实验软硬件环境

**软件环境**：gcc version 7.3.0 (x86_64-posix-sjlj-rev0, Built by MinGW-W64 project)，Windows10 1607 OS Version 1493.2068

**硬件环境**：处理器：Intel（R）Core（TM）2 Duo CPU E7500@2.93GHz 2.94 GHz 已安装的内存（RAM）：4.00GB

### 实验内容

> 为基于共享主存解决读者-写着问题，需要由写进程首先创建一个共享主存，并将该共 享主存区映射到虚拟地址空间，随后读进程打开共享主存，并将该共享主存区映射到自己 的虚拟地址空间，从中获取数据，并进行处理，以此实现进程通信。 

程序模板：

**写者：**

```c
#include <sys/ipc>
#include <sys/shm.h>
Typedef struct {
   char name[4];
   int  age;
 }people;
Main(int argc, char **argv)
{
     /*调用ftok函数创建一个键值*/
     if(创建键值失败)
             /*打印“创建键值失败”提示信息*/
     /*调用shmget创建一块共享主存区*/
     /*将共享主存区附加到自己的主存段*/
     /*向共享主存中写入数据*/
     /*将其从自己的贮存段中删除出去*/
}

```

**读者：**

```c
#include  <sys/ipc.h>
#include <sys/shm.h>
Typedef struct{
      char name[4];
       int age;
}people;
Main(int argc, char **argv)
{
       /*调用ftok函数创建一个键值*/
     if(创建键值失败)
             /*打印“创建键值失败”提示信息*/
     /*调用shmget创建一块共享主存区*/
     /*将共享主存区附加到自己的主存段*/
     /*从共享主存中读取数据*/
     /*将其从自己的贮存段中删除出去*/
}

```

### 实验程序及分析

**实验程序：**



**实验分析：**

1. 本次实验中，两个进程之间通过共享主存的方式进行通信，实现共享主存，就要先创建一个共享内存区，共享内存区通过 `shmget` 函数进行实现，其函数原型为：

   `int shmget(key_t  key, size_t  size, int shmflg) `

   该函数能在主存中开辟一段大小为 `size` 的空间，用于进程间的资源共享

2. 共享内存建立之后，需要将内存区映射到当前进程的地址空间，之后才能进行访问操作，映射共享内存的函数操作为：`shmat` 其返回值为一个当前进程的地址空间

3. 在本实验中，两个进程之间共享的数据为一结构体数据，其有两个子元素，一是一个字符类型数组，用来保存一个姓名，二为一个 int 类型数据，用于保存年龄。在写者进程中，对共享主存区的该结构体进行赋值操作，在读者进程中，进行访问和读取，并把获取到的数据打印在屏幕上，实现进程之间的数据共享和通信



### 实验心得及体会

通过这次实验，我掌握了使用共享主存的方式进行进程通信的方法。掌握了共享主存区的分配和挂载操作，对共享主存的实现方式有了进一步的了解，并成功运用共享主存实现了读者和写者进程之间的数据通信，在实验的过程中，出现了共享主存区分配失败和权限不正确的问题，仔细检查发现是传入参数有误的原因。通过这几次的操作系统上机实验，使我对所学的相关知识有了更深的体验和了解，感受到了操作系统功能实现的巧妙，培养了我动手实践和代码编写，调试的能力，增强了我独立实践解决问题的能力，使我受益匪浅。

