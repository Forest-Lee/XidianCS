# 第四章 死锁

## 死锁的原因

1. 进程推进顺序不当
2. 对互斥资源的分配不当

> **系统资源不足并不是产生死锁的原因**，进程资源如果不足则进程就 不会被创建，只有在资源部分分配以后，剩余的资源不能满足某些个进程的请求，造成进程集无法推进的现象才是死锁。  

## 产生死锁的四个必要条件

1. **互斥条件：** 任一时刻只允许一个进程使用资源。  
2. **非剥夺控制：**只能由占用资源的进程自己释放资源
3. **零散请求（保持和等待）**：进程占有部分资源，申请更多的资源
4. **循环等待：**请求资源的进程形成了循环

## 死锁的处理

### 忽略死锁（鸵鸟算法）

### 死锁的检测与恢复

- 资源分配图

  - 静态资源分配

    删除所有未阻塞进程，释放其占有资源

  - 临时资源分配图

    删除未阻塞进程的请求边，使其请求的资源数减一

- 死锁解除

  - 重新启动系统
  - 撤销进程
  - 剥夺资源
  - 进程回退

### 死锁的避免

**用动态的方法判断资源的使用情况和系统的状态，分配资源之前，判断是否会发生死锁，如果会，资源就不分配**

1. 安全状态

   某一时刻，系统能按某种顺序为每个进程分配其所需资源，使每个进程都能顺利地完 成，则称此时系统处于安全状态。反之，称之为不安全状态。 

   **不安全状态不一定发生死锁，死锁一定属于不安全状态**

   ==即寻找一个安全序列==

2. 银行家算法

   - 单个资源的银行家算法

   一个小城镇的银行家，他向一群客户分别承诺了一定的贷款额度，算法要做的是判断对请求的满足是否会进入不安全状态，如果是，就拒绝请求；否则予以分配。

   [![img](https://github.com/CyC2018/Interview-Notebook/raw/master/pics/d160ec2e-cfe2-4640-bda7-62f53e58b8c0.png)](https://github.com/CyC2018/Interview-Notebook/blob/master/pics/d160ec2e-cfe2-4640-bda7-62f53e58b8c0.png)

    

   上图 c 为不安全状态，因此算法会拒绝之前的请求，从而避免进入图 c 中的状态。

   - 多个资源的银行家算法

   [![img](https://github.com/CyC2018/Interview-Notebook/raw/master/pics/62e0dd4f-44c3-43ee-bb6e-fedb9e068519.png)](https://github.com/CyC2018/Interview-Notebook/blob/master/pics/62e0dd4f-44c3-43ee-bb6e-fedb9e068519.png)

    

   上图中有五个进程，四个资源。左边的图表示已经分配的资源，右边的图表示还需要分配的资源。最右边的 E、P 以及 A 分别表示：总资源、已分配资源以及可用资源，注意这三个为向量，而不是具体数值，例如 A=(1020)，表示 4 个资源分别还剩下 1/0/2/0。

   检查一个状态是否安全的算法如下：

   - 查找右边的矩阵是否存在一行小于等于向量 A。如果不存在这样的行，那么系统将会发生死锁，状态是不安全的。
   - 假若找到这样一行，将该进程标记为终止，并将其已分配资源加到 A 中。
   - 重复以上两步，直到所有进程都标记为终止，则状态时安全的。

   如果一个状态不是安全的，需要拒绝进入这个状态。

### 死锁的预防

**死锁的预防策略是以破坏死锁产生的必要条件为目的，对资源的申请加以限制的**

破坏互斥条件：某些设备可以通过 SPOOLING 系统将独享设备改造成为共享设备，以此 可以解决互斥问题，例如打印机。 破坏非剥夺条件：资源暂时释放策略，申请新的资源得不到满足则暂时释放已有的资 源。 破坏占用并请求条件；一次性申请全部资源。 破坏循环等待条件：资源有序申请，给资源编号，使用时按升序进行

