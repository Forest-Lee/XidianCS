# 第三章 进程管理

## 引言：进程的引入

现在的操作系统多为并发执行，为了提高资源的利用率

1. 顺序执行

    > 顺序执行是单道批处理系统的执行方式 
    >
    > 程序在执行时，各程序段必须按照先后次序逐个执行。程序各程序段的这种先后次序可用前趋图表示。 

    **特点：** 顺序、封闭（独占、资源状态无法改变）、可再现

2. 多道程序设计

    > 把一个以上的程序放入内存中，并且同时处于运行状态，这些程序共享CPU和其它资源。

    **特点：**

    1. **多道**：内存中由多道程序，处于就绪、运行、阻塞三种状态
    2. **宏观上并行**
    3. **微观上串行**
    4. 优点：**CPU、设备利用率高，系统吞吐量大**
    5. 缺点：多道程序设计复杂，内存需求大，外围设备调度管理复杂

3. 并发执行

    > 一段时间内有多道程序在同时运行称为并发性

    **特征：**

    1. 失去封闭性：共享资源，程序之间互相制约
    2. 间断性：程序执行时间不连贯
    3. 不可再现：程序执行的结果随速度，环境的不同而不同

    **并行是并发的特例，并发是并行的拓展**

    引入**进程**，反映程序执行的独立性、并发性和动态性
## 进程

### 1. 进程的定义

==**「进程是程序的一次执行，该程序可以和其他程序并发执行；它是一个动态实体，在传统的操作系统设计中，进程既是基本的分配单元，也是基本的执行单元」**==

### 2. 进程和程序的区别

**进程最基本的属性是「动态性」 和 「并发性」**

1. 程序是永存的，进程是暂时的 
2. 程序是静态的观念，进程是动态的观念
3. 进程由三部分组成：程序+数据+进程控制块（描述进程活动情况的数据结构）
4. 进程和程序不是一一对应的 
   - 一个程序可对应多个进程即多个进程可执行同一程序
   - 一个进程可以执行一个或几个程序 

### 3. 进程的组成

**由==程序段、数据段和进程控制块(PCB)==组成。**

1. **程序和数据** 是进程的实体

2. **进程控制块** 是进程存在的唯一标志

   > 进程控制块 (Process Control Block, PCB) 描述进程的基本信息和运行状态，所谓的创建进程和撤销进程，都是指对 PCB 的操作。 

操作系统为进程 **创建进程控制块** 和 **分配地址空间** 的过程就是进程创建的过程

### 4. 进程控制块

1. 进程控制块的构成：

   **操作系统记录进程状态和信息的基本数据结构， 包括**

   1. **标识信息**
     唯一标示进程，有**进程标识**（创建进程时分配的唯一代码），**用户标识**（指明进程的所有者）和 **父进程标识**（指明创建该进程的进程标识）

   2. **现场信息**
     与 CPU 有关的现场信息，寄存器状态、堆栈指针，用户中断之后的恢复

   3. **控制信息**
     操作系统对其进行调度室用到的信息。有进程状态，调度信息、队列指针、资源占有使用信息

2. 进程控制块的组织方式

  1. 以队列形式存在
  2. **以表的形式存在——PCB表**，有 **链接方式** （队列指针直接保存 PCB 的地址） 和 **索引方式** （除执行指针外，其他状态进程的 PCB 信息，由对应的索引表保存）

3. 进程控制块的作用

  进程控制块是进程组成中最关键的部分。

  - 每个进程有唯一的PCB。
  - 操作系统根据PCB对进程实施控制和管理。
  - 进程的动态、并发等特征是利用PCB表现出来的。 
  - PCB是进程存在的唯一标志。
### 5. 进程的基本状态

1. 三状态模型：

   **进程的3种基本状态是：运行态、就绪态和阻塞态。**

   - **运行态（Running）** 
     占有CPU，并在CPU上运行
   - **就绪态（Ready）** 
     已经具备运行条件，但由于没有空闲CPU，而暂时不能运行
   - **等待态（Waiting/Blocked）** （其他说法：阻塞态、封锁态、睡眠态） 
     因等待某一事件而暂时不能运行

   ![mark](http://7xjpym.com1.z0.glb.clouddn.com/blog/180514/I7G4K4C3Ka.png?imageslim)

   **应该注意以下内容：**

   - 只有就绪态和运行态可以相互转换，其它的都是单向转换。就绪状态的进程通过调度算法从而获得 CPU 时间，转为运行状态；而运行状态的进程，在分配给它的 CPU 时间片用完之后就会转为就绪状态，等待下一次调度。
   - 阻塞状态是缺少需要的资源从而由运行状态转换而来，但是该资源不包括 CPU 时间，缺少 CPU 时间会从运行态转换为就绪态。

2. 五状态模型

   ![mark](http://7xjpym.com1.z0.glb.clouddn.com/blog/180514/4m7dDhcDBh.png?imageslim)

   新增 「新建态」和「终止态」：
   1. 新建态：
     已经完成创建进程的工作，但因为资源不足，进程未执行
   2. 终止态：
     终止执行后，进行资源回收

3. 七状态模型

   ![mark](http://7xjpym.com1.z0.glb.clouddn.com/blog/180514/Bc2f68l4Dm.png?imageslim)

4. 进程队列

   队列是常用的组织各进程 PCB 的一种方式，可以按照不同的状态和等待原因的不同，进一步细化为多个队列

   ![mark](http://7xjpym.com1.z0.glb.clouddn.com/blog/180514/JbdaLdhHfA.png?imageslim)

   

### 6. 进程控制

**通过原语(Primitive)实现**

> 原语是指由机器指令构成的可完成特定功能的程序段。它是一个机器指令的集合，在执行时不能被中断。多采用屏蔽中断方法实现。 

原语有：创建、撤销、阻塞、唤醒、挂起、激活 原语

### 7. 进程关系的树形结构

优点：
1. **资源分配严格**：
只能分配到父进程资源
2. **进程控制灵活**
可以给进程不同的控制权限
3. 进程结构清楚，关系明确

### 10. 进程的特征
1. 动态性，执行，过程强调动态性
2. 并发性
3. 异步性：各进程按照独立的不可预知的速度推进，导致进程执行不可再现
4. 独立性
进程是独立运行的基本单位，一个独立获得资源和独立调度的单位
5. 制约性
执行可能依赖其他进程的执行结果
6. 结构性
进程有固定结构，包括程序、数据、PCB

## 进程调度

> 进程调度是低级调度，从就绪队列中选择某个进程占用 cpu

### 1. 批处理系统中的调度

#### 1.1 先来先服务

> first-come first-serverd（FCFS）

调度最先进入就绪队列的作业。

有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。

#### 1.2 短作业优先

> shortest job first（SJF）

调度估计运行时间最短的作业。

长作业有可能会饿死，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度。

#### 1.3 最短剩余时间优先

> shortest remaining time next（SRTN）

### 2. 交互式系统中的调度

#### 2.1 优先级调度

除了可以手动赋予优先权之外，还可以把响应比作为优先权，这种调度方式叫做高响应比优先调度算法。

响应比 = (等待时间 + 要求服务时间) / 要求服务时间 = 响应时间 / 要求服务时间

这种调度算法主要是为了解决短作业优先调度算法长作业可能会饿死的问题，因为随着等待时间的增长，响应比也会越来越高。

#### 2.2 时间片轮转

将所有就绪进程按 FCFS 的原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 时间分配给队首的进程。

时间片轮转算法的效率和时间片的大小有很大关系。因为进程切换都要保存进程的信息并且载入新进程的信息，如果时间片太小，会导致进程切换得太频繁，在进程切换上就会花过多时间。

#### 2.3 多级反馈队列

[![img](https://github.com/CyC2018/Interview-Notebook/raw/master/pics/042cf928-3c8e-4815-ae9c-f2780202c68f.png)](https://github.com/CyC2018/Interview-Notebook/blob/master/pics/042cf928-3c8e-4815-ae9c-f2780202c68f.png)

 

如果一个进程需要执行 100 个时间片，如果采用轮转调度算法，那么需要交换 100 次。多级队列是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列，每个队列时间片大小都不同，例如 1,2,4,8,..。进程在第一个队列没执行完，就会被移到下一个队列。这种方式下，之前的进程只需要交换 7 次。

每个队列优先权也不同，最上面的优先权最高。因此只有上一个队列没有进程在排队，才能调度当前队列上的进程。



## 进程间的相互作用

**同步** ： 多个进程按一定顺序执行； 

>  **临界资源**： 一段时间内只允许一个进程访问的资源

**互斥**： 多个进程在同一时刻只有一个进程能进入临界区。 

**临界区（互斥区）**： 进程中涉及到临界资源的程序段

#### 信号量以及 PV 操作

**信号量（Semaphore）** 是表示资源的实体，是一个与队列有关的整形变量，其值只能由 P、V 操作改变

**公用信号量**：用于实现进程之间的互斥，初始值为 1 ，它联系的一组并行进程均可对它实施 P、V 操作

**私用信号量**： 实现进程之间的同步，初始值为 0 或 n

> **PV 操作是原语操作**

**信号量的数据结构**：

```c
struct semaphore{
    int value;
    pointer_PCB queue;
}

P(s){
    s.value = s.value-1;
    if (s.value<0){
        该进程状态置为等待;
        该进程的 PCB 插入相应的等待队列末尾 s.queue;
    }
}

V(s){
    s.value = s.value + 1;
    if(s.value<0){
        唤醒相应等待队列中等待的一个进程;
        改变其状态为就绪态;
        将其插入就绪队列;
    }
}
```

**信号量值的含义**： 

1. `s.value >= 0` 时， 其值表示还有可用的资源数
2. `s.value < 0` 时，其绝对值表示有多少个进程处于阻塞态

**实例：**

1. **生产者——消费者问题**

   > **问题描述：**使用一个缓冲区来保存物品，只有缓冲区没有满，生产者才可以放入物品；只有缓冲区不为空，消费者才可以拿走物品。 

   因为缓冲区属于临界资源，因此需要使用一个互斥量 $mutex$ 来控制对缓冲区的互斥访问。 

   生产者进程：

   ```c
   while(true){
       生产一件产品;
       P(S缓);					/*申请一个空缓冲区*/
       P(mutex);				 /*申请缓冲区的使用权*/
       放入一件产品；
       V(mutex);				 /*释放缓冲区的使用权*/
       V(S产); 					/*释放产品增加满缓冲区*/
   }
   
   ```

   消费者进程：

   ```c
   while(true){
       P(S产); 					/*申请一个满缓冲区*/
       P(mutex);				/*申请缓冲区的使用权*/
       拿出一件产品;
       V(mutex);				/*释放缓冲区的使用权*/
       V(S缓);					/*增加空缓冲区*/
       消费产品;
   }
   
   ```

   注意，不能先对缓冲区进行加锁，再测试信号量。也就是说，不能先执行 P(mutex) 再执行 P(S缓)。如果这么做了，那么可能会出现这种情况：生产者对缓冲区加锁后，执行 P(S缓) 操作，发现 S缓 = 0，此时生产者睡眠。消费者不能进入临界区，因为生产者对缓冲区加锁了，也就无法执行 V(S缓) 操作，S缓 永远都为 0，那么生产者和消费者就会一直等待下去，造成死锁。 

2. **读者——写者模型**

   > 允许多个进程同时对数据进行读操作，但是不允许读和写以及写和写操作同时发生。 

   一个整型变量 count 记录在对数据进行读操作的进程数量，一个互斥量 count_mutex 用于对 count 加锁，一个互斥量 data_mutex 用于对读写的数据加锁。 

   读者进程：

   ```c
   P(mutex);
   readnum=readnum+1;
   if (readnum==1) P(write);
   V(mutex);
   read file;
   P(mutex); 
   readnum=readnum－1;
   if (readnum==0) V(write);
   V(mutex);
   
   ```

   写者进程：

   ```c
   P(write);
   write file;
   V(write);
   ```

**使用注意**：

1. **互斥操作时，P、V在同一进程中，同步操作时，处于不同的进程**
2. **对互斥信号量的 P 操作在后**