# 第二章 用户接口与作业管理

## 作业

1. 基本概念
  作业是**用户一次请求计算机系统为他完成任务所进行的工作总和**

2. 作业类型
    1. 脱机作业
        不直接交互，通常用于批处理系统
    2. 联机作业
        直接交互，用于分时系统和微机系统

3. 作业的组成
    **包括： ==程序、数据、作业控制信息（作业说明书）== 三部分**

4. ==作业的处理过程==
    ```mermaid
    graph TB;
    subgraph 
    sr(用户提交作业)-->hb(建立作业控制块,加入后备作业队列)
    hb-->vz(分为就绪运行阻塞状态)
    vz-->f(正常结束或错误终止)
    end
    subgraph 
    输入---sr
    后备---hb
    执行---vz
    完成---f
    end
    ```
    ![mark](http://media.sumblog.cn/blog/180509/0Gi3bcJEdd.png?imageMogr2/thumbnail/!60p)

## 作业的输入/输出方式

1. 联机输入、输出
    主机控制I/O

2. 脱机输入/输出
    外围处理机控制， 人工干预

3. 脱机输入/输出

4. SPOOLing 系统
    用磁盘来模拟独占设备的操作，==**一台独占设备变成多台并行的虚拟设备（独占变共享）**==，==兼具脱机和联机方式的优点，可以实现联机方式下的主机和外围设备的同时工作==，又称为假脱机 

    SPOOLing 由专门负责 I/O 的==常驻内存进程==和==**输入输出井**==组成
    **作用：** 独占变共享，实现了虚拟设备的功能

    ![mark](http://media.sumblog.cn/blog/180514/6b3hgKL3hd.png?imageslim)

## 作业控制块

==作业控制块 JCB 是作业存在的**唯一标志**==，当作业进入系统后，系统会为其创建作业控制块，用来存放管理和控制作业所必须的信息，只有作业退出系统后，JCB 才被撤销

> JCB 包含该作业的标识信息、状态信息、调度参数、资源需求和其他控制信息
>
> 例如：1）作业名 2）用户名 3）语言程序类型（需调用的系统程序） 4）内存需求量5）估计执行时间 6）优先数（用于调度） 7）作业类型 8）作业说明书文件名 9）资源要求：（静态，或中间可以随作业步变化－－效率不高；动态分配 10）作业状态：提交、后备、执行、就绪、等待、完成

**作业后备队列**就是按照某种原则将后备作业的 JCB 排成的一个或多个序列，以便作业调度。

## 作业调度

### 1. 多级调度结构

> 计算机内的调度结构：
>
> ![mark](http://media.sumblog.cn/blog/180514/Kl2DI48emL.png?imageMogr2/thumbnail/!70p)
>
> 由上图可以看出，作业调度跟进程调度是密切相关的，首先进行作业调度将使之进入就绪队列，然后进行进程调度，或者进程执行完毕继续下面的进程，或者挂起等待下一轮的调度。下面结合生活中的例子分析一下两级调度。
>
> 第一级的作业调度是会将一批作业同时装入内存，以淋浴公共澡堂为例，里面可能只有1个水龙头，但可以一次让三四个人一起进去洗，因为洗澡的人并不是总要占着水龙头，只要相互错开就行了。那么澡堂就可以规定一次进三个人，三个洗完，再进三个。
>
> 第二级调度就是进程调度了，三个人同时用水龙头，那这个水龙头就相当于CPU，当然也可以多个水龙头，那就是多处理器了。洗的过程中，三个人可能有的在搓澡，有的在帮别人搓澡，也有可能都打完香皂就等冲水了，那让谁用水龙头呢？一般就是排先后，先申请的先用原则，但也不一定，比如有一个人说给我十秒钟冲一下就洗完了，那就是个短作业，不妨让他先用，洗完他就走了，这样大家的平均等待时间会缩短，也算是提高了效率；再就是有一个人可能在洗的过程中突然被洗发水迷了眼，所以需要赶紧冲一下，这就是高优先级的作业了，不同优先级之间，先可着高优先级的进行调度，这也是一种原则。所以总的来说，进程调度是在多个就绪进程中按一定的策略选出当前应执行的进程，合适与否，是按一定的策略遴选出来的。
>
> **简单比喻：作业调度是演员上场前的准备，进程调度是让演员上场表演。**

1. **高级调度：**
    **作业调度**，使后备作业进入主机

    作业就是用户程序及其所需的数据和命令的集合，作业管理就是对作业的执行情况进行系统管理的程序的集合。作业调度程序的主要功能是审查系统是否能满足用户作业的资源要求以及按照一定的算法来选取作业。 

2. **中级调度：**
    对换调度，主机中的作业在 ram（内存） 和 swap 区间（硬盘）的调换

    提高内存的利用率和系统吞吐量，使得暂时不运行的进程从内存对换到外存上。 

3. **低级调度：**
    **进程调度：**决定 ram 中的哪个进程可以占用 cpu， 开始运行

    根据一定的算法将cpu分派给就绪队列中的一个进程。进程调度是操作系统中最基本的一种调度，其调度策略的优劣直接影响整个系统的性能。 

![mark](http://media.sumblog.cn/blog/180514/A2G9lLfE38.png?imageMogr2/thumbnail/!60p)



### 2. 作业调度算法的评价指标

1. **CPU 利用率**

   CPU 忙碌时间占总时间的百分比

2. 吞吐量

   **单位时间内 CPU 完成作业的数量**

3. **周转时间 和 周转系数**

   若作业 $J_i$ 的提交时间为 $t_{si}$ , 执行时间为 $t_{ri}$ 完成时间为 $t_oi$
   作业 $J_i$ 的==周转时间：*从提交到完成的总时间*==
   $$
   T_i = t_{oi} - t_{si}   \qquad  i=1,2,...n
   $$
   ==周转系数：周转时间/执行时间==      *总时间 / 有用的时间*
   $$
   W_i = T_i/t_{ri}
   $$
   **n 个 作业的平均周转时间，平均周转系数**
   $$
   T = \frac{1}{n} \sum_{i=1}^{n}T_i
   $$

   $$
   W = \frac{1}{n}\sum_{i=1}^{n}W_i
   $$

   作业的平均周转时间越短，系统的吞吐量就越高

> 要想提高吞吐量，就应优先考虑运行短作业；若要提高 CPU 利用率，则应优先考虑长作业

###  常见的作业调度算法

1. 单道批处理系统作业调度算法
   1. ==**先来先服务(FCFS)**==

       > 按作业到达先后进行调度，即启动等待时间最长的作业。这种算法忽视了吞吐量和平均周转时间 

       有利于长作业，不利于短作业，不利于IO 繁忙的作业

   2. ==**短作业优先调度（SJF）**==

       > 以要求运行时间长短进行调度，即启动要求运行时间最短的作业。 

       这种算法可以有效降低作业的平均等待时间，提高系统的吞吐量， 对长作业不利，出现饥饿现象，未考虑作业的紧迫程度。

   3. ==**最高响应比优先算法 (HRP)**==

       > 优先调度响应比高的作业
       >
       >    响应比RP＝作业响应时间/作业估计运行时间
       >
       >    ＝**（作业估计运行时间+作业等待时间）/作业估计运行时间**
       >
       >    ＝ ==**1 + 作业已等待时间/作业估计运行时间**==

       响应比 RP = 作业响应时间/作业估计运行时间 = （作业估计运行时间+作业等待时间）/ 作业估计运行时间=1+作业等待时间/作业估计运行时间

2. 多道批处理系统作业调度算法

   1. **优先级调度算法**
       用户指定优先级进行调度，优先级高的作业先启动

   2. 均衡调度算法

       > 这种算法的基本思想是根据系统的运行情况和作业本身的特性对作业进行分类。作业调度程序轮流地从这些不同类别的作业中挑选作业执行。这种算法力求均衡地使用系统的各种资源。 

       根据作业特性进行分类挑选

**总结：就平均周转时间和平均周转系数来说，最短作业优先算法最小 ，先来先服务算法最大， 响应比高优先算法居中**

> 例：性能分析
>
> 设有四个作业，其提交时刻、执行时间如下表所示： 
>
> | 作业号 | 提交时刻 | 运行时间 |
> | ------ | -------- | -------- |
> | 1      | 8.00     | 2.00     |
> | 2      | 8.50     | 0.50     |
> | 3      | 9.00     | 0.10     |
> | 4      | 9.50     | 0.20     |
>
> 1. 先来先服务调度算法：顺序为1 2 3 4，计算平均周转时间T和平均周转系数W，如下表所示。
>
>    ![mark](http://media.sumblog.cn/blog/180514/EbE65fcLI8.png?imageslim)
>
> 2. 最短作业优先调度算法：由于在8.00开始执行作业，当时仅有1，而作业2，3，4尚未到达，故作业1是最短作业。作业1执行完成后是10.00，此时作业2，3，4均已经到达，故选最短作业3，然后是4，2。所以顺序为1,3,4,2。平均周转时间和平均周转系数的计算结果如下表所示。 
>
>    ![mark](http://media.sumblog.cn/blog/180514/ACGJF96dJ9.png?imageslim)
>
> 3. 响应比高者优先算法：在作业1执行完成，计算作业2，3，4的响应比分别为：4，11，3.5，因此作业1执行完成后选中作业3完成。执行顺序为1，3，2，4。按此算法求得的平均周转时间和平均周转系数如下表所示。
>
>    ![mark](http://media.sumblog.cn/blog/180514/ll2jehde8K.png?imageslim)
>
> 



## 系统功能调用

1. **管态（内核态） 和 目态（用户态）**

   > 现代CPU一般都有几种不同的指令执行级别；在高执行级别下，代码可以执行**特权指令，访问任意的物理地址**，这种CPU执行级别就对应着内核态；在相应的低级别执行状态下，代码的掌控范围 会受到限制。只能在对应级别允许的范围内活动 

   ==管态（系统态）：操作系统程序运行的状态==

   ==算态（目态）：用户程序运行的状态==

   **特权指令：**只能在管态下执行而不能在算态下执行的特殊指令

   > 常见的特权指令有如下几类：
   >
   > 1. 传送程序状态字的指令
   >
   >    > 程序状态字通常包括以下状态代码：  CPU的工作状态码——指明管态还是目态，用来说明当前在CPU上执行的是操作系统还是一般用户，从而决定其是否可以使用特权指令或拥有其它的特殊权力  条件码——反映指令执行后的结果特征  中断屏蔽码——指出是否允许中断 
   >
   > 2. 启动、测试和控制外设的指令
   >
   > 3. 存取特殊寄存器的指令

2. 系统功能调用

   **用户在程序中用 *访管指令* 调用由操作系统提供的子功能集合。 **

   > ==访管指令：本身不是特权指令==，基本功能是“自愿进管”，能引起访管中断。 

   **系统功能的调用方法：**
    ![mark](http://media.sumblog.cn/blog/180514/76cjmL43lD.png?imageMogr2/thumbnail/!60p)
   系统功能调用与普通过程调用的区别：

   1. 运行在不同的系统状态 （一次指令运行，跨越目态和管态）
   2. 进入方式不同：需要先通过软终端机制，进入操作系统核心，经过核心处理，转向相应的命令处理程序



